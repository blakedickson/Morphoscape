[{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/articles/Morphoscape.html","id":"phenotype","dir":"Articles","previous_headings":"Defining a morphospace","what":"Phenotype","title":"Morphoscape","text":"Adaptive landscape analyses require two types data married together: phenotypic data performance data. Phenotype data can take many forms, requirement phenotype data construction adaptive landscapes definition morphospace. simplest type morphospace can 2D plot axes defined two numeric measurements phenotype, length width skull, though quantification phenotype valid. Geometric morphometrics become quintessential method quantifying detailed shape variation bony structures, final outcome many studies visualization PCA shape variation - morphospace. However, one defines morphospace can drastically impact outcomes adaptive landscape analyses. PCA -group PCA valid methods ordinate morphological data, yet produce dramatically different morphospaces depending goals analysis. PCA produce (largely) unbiased ordination major axes variation, bgPCA find axes variation maximize differences groups. Caution applied using constrained ordination like bgPCA, can create ecological patterns none may actually exist (see Bookstein 2019, Cardini et al 2019 Cardini & Polly 2020 cautionary debate). However, many ways bgPCA, constrained ordinations ideal questions regarding functional adaptive differences ecological groups actual morphological differences present. now adaptive landscape methods package limited 2D morphospaces, two axes phenotypic variation. largely done complexities involved analyzing visualizing multivariate covariance 3 dimensions. However, two axes phenotypic variation desired analyzed, can done separate analyses.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/articles/Morphoscape.html","id":"collecting-performance-data-specimens-or-warps","dir":"Articles","previous_headings":"Defining a morphospace","what":"Collecting performance data: Specimens or Warps","title":"Morphoscape","text":"ordination 2D morphospace phenotypic data defined, one must collect data performance phenotypes. two approaches one can take collecting performance data: collect data directly specimens, collect data phenotypic warps morphospace. former simplest direct long dataset large, allows know actual performance actual specimens. However, error can creep performance traits strongly covary axes morphospace, can produce uneven inconsistent surfaces. addition, specimens may evenly occupy morphospace resulting regions morphospace defined existing phenotypes, thus measured performance data may produce erroneous interpolations extrapolations performance. Finally, collecting performance data can time consuming, may impractical extremely large datasets. alternative collect performance data hypothetical warps across morphospace, eliminates issues. long method used define morphospace reversible (prcomp, geomorph::gm.prcomp, Morpho::prcompfast, Morpho::groupPCA, Morpho::CVA), possible extract phenotype location morphospace. fact many ordination functions come predict methods task. , using prediction, possible define phenotypes evenly across morphospace called warps. warps also useful can defined represent phenotypic variation axes morphospace, ignore variation axes. warps can however form biologically impossible phenotypes (walls bone crossing one another), may may help interpretations regions morphospace might occupied . approaches valid long morphospace reasonably well covered. -depth analysis morphospace sampling see Smith et al (2021). package comes turtle humerus dataset Dickson Pierce (2019), uses performance data collected warps. turtles dataset coordinate data 40 turtle humerus specimens ordinated bgPCA morphospace, first two axes maximizing differences three ecological groups: Marine, Freshwater Terrestrial turtles. dataset also includes ecological groupings. warps dataset 4x6 evenly spaced warps predicted morphospace 4 performance metrics.","code":"data(\"turtles\") data(\"warps\")  str(turtles) #> 'data.frame':    40 obs. of  4 variables: #>  $ x      : num  0.03486 -0.07419 -0.07846 0.00972 -0.00997 ... #>  $ y      : num  -0.019928 -0.015796 -0.010289 -0.000904 -0.029465 ... #>  $ Group  : chr  \"freshwater\" \"softshell\" \"softshell\" \"freshwater\" ... #>  $ Ecology: chr  \"S\" \"S\" \"S\" \"S\" ... str(warps) #> 'data.frame':    24 obs. of  6 variables: #>  $ x    : num  -0.189 -0.189 -0.189 -0.189 -0.134 ... #>  $ y    : num  -0.05161 -0.00363 0.04435 0.09233 -0.05161 ... #>  $ hydro: num  -1839 -1962 -2089 -2371 -1754 ... #>  $ curve: num  8.07 6.3 9.7 15.44 10.21 ... #>  $ mech : num  0.185 0.193 0.191 0.161 0.171 ... #>  $ fea  : num  -0.15516 -0.06215 -0.00435 0.14399 0.28171 ..."},{"path":"https://blakedickson.github.io/Morphoscape/articles/Morphoscape.html","id":"using-morphoscape","dir":"Articles","previous_headings":"","what":"Using Morphoscape","title":"Morphoscape","text":"morphospace defined performance data collected, workflow using Morphoscape fairly straightforward. Using warp turtles datasets first step make functional dataframe using as_fnc_df(). input function dataframe containing coordinate data performance data (also grouping factors desired). first two columns must coordinates, columns can defined performance data, grouping factors. best performance data named point keep track.","code":"library(Morphoscape)  data(\"turtles\") data(\"warps\")  str(turtles) #> 'data.frame':    40 obs. of  4 variables: #>  $ x      : num  0.03486 -0.07419 -0.07846 0.00972 -0.00997 ... #>  $ y      : num  -0.019928 -0.015796 -0.010289 -0.000904 -0.029465 ... #>  $ Group  : chr  \"freshwater\" \"softshell\" \"softshell\" \"freshwater\" ... #>  $ Ecology: chr  \"S\" \"S\" \"S\" \"S\" ... str(warps) #> 'data.frame':    24 obs. of  6 variables: #>  $ x    : num  -0.189 -0.189 -0.189 -0.189 -0.134 ... #>  $ y    : num  -0.05161 -0.00363 0.04435 0.09233 -0.05161 ... #>  $ hydro: num  -1839 -1962 -2089 -2371 -1754 ... #>  $ curve: num  8.07 6.3 9.7 15.44 10.21 ... #>  $ mech : num  0.185 0.193 0.191 0.161 0.171 ... #>  $ fea  : num  -0.15516 -0.06215 -0.00435 0.14399 0.28171 ...  # Create an fnc_df object for downstream use warps_fnc <- as_fnc_df(warps, func.names = c(\"hydro\", \"curve\", \"mech\", \"fea\")) str(warps_fnc) #> Classes 'fnc_df' and 'data.frame':   24 obs. of  6 variables: #>  $ x    : num  -0.189 -0.189 -0.189 -0.189 -0.134 ... #>  $ y    : num  -0.05161 -0.00363 0.04435 0.09233 -0.05161 ... #>  $ hydro: num  0.763 0.627 0.487 0.174 0.858 ... #>  $ curve: num  0.0544 0 0.1045 0.281 0.1202 ... #>  $ mech : num  0.359 0.473 0.446 0 0.149 ... #>  $ fea  : num  0.372 0.458 0.512 0.65 0.777 ... #>  - attr(*, \"func.names\")= chr [1:4] \"hydro\" \"curve\" \"mech\" \"fea\""},{"path":"https://blakedickson.github.io/Morphoscape/articles/Morphoscape.html","id":"creating-performance-surfaces","dir":"Articles","previous_headings":"Using Morphoscape","what":"Creating Performance Surfaces","title":"Morphoscape","text":"simple process perform surface interpolation automatic Kriging using krige_surf() function. autofit kriging function data. performed automap::autoKrige() function. details fitting variograms read documentation automap. autoKrige fitting data kept kriged_surfaces object along output surface. default krige_surf() function interpolate within alpha hull wrapped around inputted datapoints. avoid extrapolation beyond measured datapoints. can defined using resample_grid() function, supply grid object defining points interpolate, optionally plot area reconstructed. strength wrapping can controlled using alpha argument, smaller values producing stronger wrapping.   However, one wishes also extrapolate full extent morphospace, set hull = NULL. warps dataset evenly samples morphospace, can set hull = NULL reconstruct full rectangle morphospace. hull = NULL amount padding also applied provide space beyond supplied datapoints can controlled using padding argument. Finally, can also specify density interpolated points using resample argument.  reconstructed surface missing actual specimen data points associated ecological groupings, needed later analyses. can added using krige_new_data() function.  course can done one step. krige_surf automatically call resample_grid() grid argument supplied, new_data can supplied data later group optimums calculated .","code":"# Create alpha-hulled grid for kriging grid <- resample_grid(warps, hull = \"concaveman\", alpha = 3, plot = TRUE) kr_surf <- krige_surf(warps_fnc, grid = grid) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] kr_surf #> A kriged_surfaces object #> - functional characteristics: #>  hydro, curve, mech, fea #> - surface size: #>  70 by 70 #>  α-hull applied (α = 3) #> - original data: #>  24 rows plot(kr_surf) # Create alpha-hulled grid for kriging grid <- resample_grid(warps, hull = NULL, padding = 1.1)  # Do the kriging on the grid kr_surf <- krige_surf(warps_fnc, grid = grid) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] kr_surf #> A kriged_surfaces object #> - functional characteristics: #>  hydro, curve, mech, fea #> - surface size: #>  100 by 100 #> - original data: #>  24 rows plot(kr_surf) # Do kriging on the sample dataset kr_surf <- krige_new_data(kr_surf, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] kr_surf #> A kriged_surfaces object #> - functional characteristics: #>  hydro, curve, mech, fea #> - surface size: #>  100 by 100 #> - original data: #>  24 rows #> - new data: #>  40 rows plot(kr_surf) # Above steps all in one: kr_surf <- krige_surf(warps_fnc, hull = NULL, padding = 1.1,                       new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] kr_surf #> A kriged_surfaces object #> - functional characteristics: #>  hydro, curve, mech, fea #> - surface size: #>  100 by 100 #> - original data: #>  24 rows #> - new data: #>  40 rows plot(kr_surf)"},{"path":"https://blakedickson.github.io/Morphoscape/articles/Morphoscape.html","id":"calculate-landscapes","dir":"Articles","previous_headings":"Using Morphoscape","what":"Calculate Landscapes","title":"Morphoscape","text":"next step calculate distribution adaptive landscapes. adaptive landscape constructed summation performance surfaces differing magnitudes, performance surface multiplied weight ranging 0-1, total sum weights equal 1. four equally weighted performance surfaces, weights vector c(0.25, 0.25, 0.25, 0.25). generate distribution different combinations weights, use generate_weights() function. generate_weights must either step n argument determine many allocations generate, nvar number variables. One can also provide either fnc_df kr_surf objects data argument. step determines step size weight values. step = 0.1 generate vectors c(0, 0.1, 0.2 ... 1). Alternatively, one can set number values sequence set. n = 10 generate vectors c(0, 0.1, 0.2 ... 1). function generate combinations nvar variables sum 1. four variables, produce 286 combinations. step size 0.05 produce 1771 rows. step size gets smaller, number variables increases, number output rows exponentially increase. recommended start large step sizes, small n ensure things working correctly. weights matrix provided calc_all_landscapes() along kr_surf object calculate landscapes set weights. calculations large number weights, outputs can take time can large size, recommended utilize file argument save output file. distribution landscapes, now possible find landscapes maximize ‘fitness’ given subset group specimens new_data using calcWprimeBy() function. argument sets grouping variable data provided new_data earlier. several ways can set: one sided formula containing name column new_data vector containing factor variable.  also possible use calcGrpWprime enumerate single group entire sample:  Finally, possible compare landscapes group using calcGrpWprime(). done comparing number landscape combinations shared upper percentile groups.","code":"# Generate weights to search for optimal landscapes weights <- generate_weights(n = 10, nvar = 4) #> 286 rows generated weights <- generate_weights(step = 0.05 , data = kr_surf) #> 1771 rows generated # Calculate all landscapes; setting verbose = TRUE produces # a progress bar all_landscapes <- calc_all_lscps(kr_surf, grid_weights = weights) # Calculate optimal landscapes by Group  table(turtles$Ecology) #>  #>  M  S  T  #>  4 29  7  wprime_by_Group <- calcWprimeBy(all_landscapes, by = ~Ecology) wprime_by_Group <- calcWprimeBy(all_landscapes, by = turtles$Ecology)  wprime_by_Group #> - turtles$Ecology == \"M\" #>  #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.22910 0.013031 0.15085  0.0 0.55 #> curve 0.03731 0.003501 0.04053  0.0 0.15 #> mech  0.09142 0.006997 0.08100  0.0 0.30 #> fea   0.64216 0.012688 0.14688  0.4 1.00 #>  #> Average fitness value at optimal weights: #>    Value      SE      SD   Min.   Max. #> Z 0.7955 0.00109 0.01261 0.7736 0.8244 #> ----------------------------------------- #> - turtles$Ecology == \"S\" #>  #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.60294 0.012506 0.11530  0.4 0.85 #> curve 0.18588 0.011401 0.10511  0.0 0.45 #> mech  0.04412 0.004909 0.04526  0.0 0.15 #> fea   0.16706 0.012343 0.11380  0.0 0.40 #>  #> Average fitness value at optimal weights: #>    Value       SE      SD   Min.   Max. #> Z 0.8511 0.001297 0.01195 0.8347 0.8854 #> ----------------------------------------- #> - turtles$Ecology == \"T\" #>  #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.03533 0.005002 0.04332 0.00 0.15 #> curve 0.70933 0.017926 0.15524 0.35 1.00 #> mech  0.21667 0.019985 0.17307 0.00 0.65 #> fea   0.03867 0.005074 0.04394 0.00 0.15 #>  #> Average fitness value at optimal weights: #>    Value       SE     SD   Min.   Max. #> Z 0.7535 0.001524 0.0132 0.7343 0.7852 #>  #> - method: chi-squared, quantile = 0.05 summary(wprime_by_Group) #> Optimal weights by turtles$Ecology: #>   W_hydro W_curve  W_mech   W_fea       Z #> M 0.22910 0.03731 0.09142 0.64216 0.79555 #> S 0.60294 0.18588 0.04412 0.16706 0.85110 #> T 0.03533 0.70933 0.21667 0.03867 0.75346 plot(wprime_by_Group, ncol = 2) # Calculate landscapes for one Group at a time  i <- which(turtles$Ecology == \"T\") wprime_T <- calcGrpWprime(all_landscapes, index = i) wprime_T #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.03533 0.005002 0.04332 0.00 0.15 #> curve 0.70933 0.017926 0.15524 0.35 1.00 #> mech  0.21667 0.019985 0.17307 0.00 0.65 #> fea   0.03867 0.005074 0.04394 0.00 0.15 #>  #> Average fitness value at optimal weights: #>    Value       SE     SD   Min.   Max. #> Z 0.7535 0.001524 0.0132 0.7343 0.7852 #>  #> - method: chi-squared, quantile = 0.05 wprime_b <- calcGrpWprime(all_landscapes, Group == \"box turtle\") wprime_b #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.07766 0.006945 0.08247  0.0 0.35 #> curve 0.69184 0.010576 0.12559  0.4 1.00 #> mech  0.17021 0.012949 0.15376  0.0 0.60 #> fea   0.06028 0.005170 0.06139  0.0 0.25 #>  #> Average fitness value at optimal weights: #>    Value       SE      SD   Min.   Max. #> Z 0.7752 0.001034 0.01228 0.7563 0.8073 #>  #> - method: chi-squared, quantile = 0.05 plot(wprime_b) wprime_all <- calcGrpWprime(all_landscapes) wprime_all #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.55405 0.014678 0.15465 0.25 0.85 #> curve 0.12523 0.008142 0.08578 0.00 0.45 #> mech  0.06937 0.005940 0.06258 0.00 0.25 #> fea   0.25135 0.013106 0.13808 0.00 0.50 #>  #> Average fitness value at optimal weights: #>    Value       SE     SD   Min.   Max. #> Z 0.7119 0.001092 0.0115 0.6947 0.7455 #>  #> - method: chi-squared, quantile = 0.05 # Test for differences between Group landscapes tests <- multi.lands.grp.test(wprime_by_Group) tests #> Pairwise landscape group tests #> - method: chi-squared | quantile: 0.05 #>  #> Results: #>   M        S T #> M -        1 0 #> S 0.007463 - 0 #> T 0        0 - #> (lower triangle: p-values | upper triangle: number of matches)  # Calculate landscapes for one Group at a time wprime_b <- calcGrpWprime(all_landscapes, Group == \"box turtle\") wprime_b #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.07766 0.006945 0.08247  0.0 0.35 #> curve 0.69184 0.010576 0.12559  0.4 1.00 #> mech  0.17021 0.012949 0.15376  0.0 0.60 #> fea   0.06028 0.005170 0.06139  0.0 0.25 #>  #> Average fitness value at optimal weights: #>    Value       SE      SD   Min.   Max. #> Z 0.7752 0.001034 0.01228 0.7563 0.8073 #>  #> - method: chi-squared, quantile = 0.05 wprime_t <- calcGrpWprime(all_landscapes, Group == \"tortoise\") wprime_t #> Optimal weights: #>        Weight       SE      SD Min. Max. #> hydro 0.02500 0.004679 0.03624  0.0 0.15 #> curve 0.73000 0.019823 0.15355  0.4 1.00 #> mech  0.20417 0.022148 0.17156  0.0 0.60 #> fea   0.04083 0.005882 0.04556  0.0 0.15 #>  #> Average fitness value at optimal weights: #>    Value       SE      SD  Min.   Max. #> Z 0.7005 0.001669 0.01292 0.682 0.7325 #>  #> - method: chi-squared, quantile = 0.05  # Test for differences between Group landscapes lands.grp.test(wprime_b, wprime_t) #> Landscape group test #> - method: chi-squared | quantile: 0.05 #>  #> Number of matches: 60 #> P-value: 0.4255"},{"path":"https://blakedickson.github.io/Morphoscape/articles/Morphoscape.html","id":"references","dir":"Articles","previous_headings":"Using Morphoscape","what":"References","title":"Morphoscape","text":"Bookstein, F. L. (2019). Pathologies -groups principal components analysis geometric morphometrics. Evolutionary Biology, 46(4), 271-302. Cardini, ., O’Higgins, P., & Rohlf, F. J. (2019). Seeing distinct groups none: spurious patterns -group PCA. Evolutionary Biology, 46(4), 303-316. Cardini, ., & Polly, P. D. (2020). Cross-validated group PCA scatterplots: solution spurious group separation?. Evolutionary Biology, 47(1), 85-95. Dickson, B. V., & Pierce, S. E. (2019). Functional performance turtle humerus shape across ecological adaptive landscape. Evolution, 73(6), 1265-1277. Smith, S. M., Stayton, C. T., & Angielczyk, K. D. (2021). many trees see forest? Assessing effects morphospace coverage sample size performance surface analysis. Methods Ecology Evolution, 12(8), 1411-1424.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/articles/Pareto.html","id":"functional-optimality","dir":"Articles","previous_headings":"Considering Optimality","what":"Functional Optimality","title":"Pareto","text":"Morphospace originally built produce functional adaptive landscapes, marrying phenotypic data (morphospace) performance data. illustrates one way thinking optimality concerns adaptive landscapes: traits, combinations, particular morphologies optimized ?","code":"data(\"turtles\") data(\"warps\")  str(turtles) #> 'data.frame':    40 obs. of  4 variables: #>  $ x      : num  0.03486 -0.07419 -0.07846 0.00972 -0.00997 ... #>  $ y      : num  -0.019928 -0.015796 -0.010289 -0.000904 -0.029465 ... #>  $ Group  : chr  \"freshwater\" \"softshell\" \"softshell\" \"freshwater\" ... #>  $ Ecology: chr  \"S\" \"S\" \"S\" \"S\" ... str(warps) #> 'data.frame':    24 obs. of  6 variables: #>  $ x    : num  -0.189 -0.189 -0.189 -0.189 -0.134 ... #>  $ y    : num  -0.05161 -0.00363 0.04435 0.09233 -0.05161 ... #>  $ hydro: num  -1839 -1962 -2089 -2371 -1754 ... #>  $ curve: num  8.07 6.3 9.7 15.44 10.21 ... #>  $ mech : num  0.185 0.193 0.191 0.161 0.171 ... #>  $ fea  : num  -0.15516 -0.06215 -0.00435 0.14399 0.28171 ...  # Make performance surfaces warps_fnc <- as_fnc_df(warps, func.names = c(\"hydro\", \"curve\", \"mech\", \"fea\")) kr_surf <- krige_surf(warps_fnc, hull = NULL, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] # Make functional adaptive landscapes weights <- generate_weights(n = 20, data = kr_surf) #> 1771 rows generated all_landscapes <- calc_all_lscps(kr_surf, grid_weights = weights) wprime_by_Group <- calcWprimeBy(all_landscapes, by = ~Ecology,method = \"quantile\")"},{"path":"https://blakedickson.github.io/Morphoscape/articles/Pareto.html","id":"pareto-optimality","dir":"Articles","previous_headings":"Considering Optimality","what":"Pareto Optimality","title":"Pareto","text":"alternative way thinking optimality comes Pareto optimality. structure might compromise different functions due inherent trade-offs. See differences performance surfaces two traits turtle dataset.   see trade-exists curvature hydrodynamic performance, simultaeneously maximize traits. trade-offs inevitably exist, morphologies handle better others. example, might able maximize two trait ssimultaeneously, can still maximize one trait given value second trait; morphologies meet criterion referred ‘Pareto optimal’. plot hydrodynamic performance vs curvature point morphospace, ‘Pareto optimal’ points fall along top left edge plot.  project points back morphospace now, Pareto optimal points form ‘Pareto front’; optimal pathway morphospace one trait optimum another. , trade-two traits least impact overall performance.  Pareto optimality generally defined terms trade-offs traits, hence example used performance surfaces input. However, can extend methods abstract case, examine trade-offs performance different adaptive landscapes, shown .   can even just one function!   noted may times shape performance surfaces adaptive landscapes smooth transition optima possible. example demonstrates two adaptive landscapes turtle dataset: marine terrestrial.","code":"# Make performance surfaces for individual traits plot_ggsurf(kr_surf,'hydro') plot_ggsurf(kr_surf,'curve') # Compute Pareto landscape for two traits KrSurfParOpt <- calc_lscp_Pareto(kr_surf,'hydro','curve') # Plot trade-offs between the traits plot_ggtrade(KrSurfParOpt) # Plot the Pareto landscape plot_ggPareto(KrSurfParOpt) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' ######### # Plot individual group landscapes plot_ggsurf(wprime_by_Group,'M') plot_ggsurf(wprime_by_Group,'S')  # Calculate Pareto landscape based on functional landscapes Lscp_Pareto_MS <- calc_lscp_Pareto(wprime_by_Group,'M','S') summary(Lscp_Pareto_MS) #>       Length Class      Mode      #> grid  5      data.frame list      #> names 2      -none-     character # Plot trade-offs between landscape heights plot_ggtrade(wprime_by_Group,'M','S') # Plot Pareto landscape between landscape heights plot_ggPareto(wprime_by_Group,'M','S') #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' plot_lscp_Pareto(wprime_by_Group,'M','S') #> [[1]] #>  #> [[2]] #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' plot_lscp_Pareto(wprime_by_Group,'M','T') #> [[1]] #>  #> [[2]] #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"https://blakedickson.github.io/Morphoscape/articles/Pareto.html","id":"references","dir":"Articles","previous_headings":"Considering Optimality","what":"References","title":"Pareto","text":"Dickson, B. V., & Pierce, S. E. (2019). Functional performance turtle humerus shape across ecological adaptive landscape. Evolution, 73(6), 1265-1277. Deakin, W.J., Anderson, P.S., den Boer, W., Smith, T.J., Hill, J.J., Rücklin, M., Donoghue, P.C. & Rayfield, E.J. (2022). Increasing morphological disparity decreasing optimality jaw speed strength radiation jawed vertebrates. Science Advances 8, eabl3644. Roocks, P. (2016). Computing Pareto frontiers database preferences rPref package.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Blake Dickson. Author, maintainer. Stephanie Pierce. Author. Noah Greifer. Author. Robert Brocklehurst. Author.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dickson B, Pierce S, Greifer N, Brocklehurst R (2025). Morphoscape: Computation Visualization Adaptive Landscapes. R package version 1.0.2, https://blakedickson.github.io/Morphoscape/.","code":"@Manual{,   title = {Morphoscape: Computation and Visualization of Adaptive Landscapes},   author = {Blake Dickson and Stephanie Pierce and Noah Greifer and Robert Brocklehurst},   year = {2025},   note = {R package version 1.0.2},   url = {https://blakedickson.github.io/Morphoscape/}, }"},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/index.html","id":"section","dir":"","previous_headings":"","what":"Computation and Visualization of Adaptive Landscapes","title":"Computation and Visualization of Adaptive Landscapes","text":"Morphoscape package designed constructions, analysis visualization spatially organized trait data adaptive landscapes. Morphoscape provides pipeline combining spatial coordinate data derived ordinated morphospace, PCA, performance trait data; finding ‘optimum’ adaptive landscapes combination trait data. Morphoscape provide tools generation morphospaces. shape analyses tools ordinate multivariate phenotypic data, see Geomorph Morpho packages. -depth guide using Morphoscape, discussion morphospace design, see vignette. install Morphoscape GitHub need install devtools package run install_github(\"blakedickson/Morphoscape\"): point entry Morphoscape dataframe containing two columns XY coordinate data followed columns containing performance variables. See warps data object example. additional dataframe turtles specimen coordinates grouping variables also provided. dataframe input as_fnc_df() coerce coordinate data correct format, rescale performance variables unit range. Performance surfaces calculated using krige_surf(), can used just calculate surfaces, also predict performance new_data points.  calculate adaptive landscapes based groupings, first population landscapes generated using generate_weights() calc_all_lscps(): Optimal landscapes groups calculated using calcWprimeBy() can statistically compared using multi.lands.grp.test():  cite Morphoscape, please run citation(\"Morphoscape\").","code":"install.packages(\"devtools\") devtools::install_github(\"blakedickson/Morphoscape\") library(Morphoscape) data('warps') str(warps) #> 'data.frame':    24 obs. of  6 variables: #>  $ x    : num  -0.189 -0.189 -0.189 -0.189 -0.134 ... #>  $ y    : num  -0.05161 -0.00363 0.04435 0.09233 -0.05161 ... #>  $ hydro: num  -1839 -1962 -2089 -2371 -1754 ... #>  $ curve: num  8.07 6.3 9.7 15.44 10.21 ... #>  $ mech : num  0.185 0.193 0.191 0.161 0.171 ... #>  $ fea  : num  -0.15516 -0.06215 -0.00435 0.14399 0.28171 ... data('turtles') str(turtles) #> 'data.frame':    40 obs. of  4 variables: #>  $ x      : num  0.03486 -0.07419 -0.07846 0.00972 -0.00997 ... #>  $ y      : num  -0.019928 -0.015796 -0.010289 -0.000904 -0.029465 ... #>  $ Group  : chr  \"freshwater\" \"softshell\" \"softshell\" \"freshwater\" ... #>  $ Ecology: chr  \"S\" \"S\" \"S\" \"S\" ... warps_fnc <- as_fnc_df(warps, func.names = c(\"hydro\", \"curve\", \"mech\", \"fea\")) kr_surf <- krige_surf(warps_fnc, hull = NULL, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] plot(kr_surf) weights <- generate_weights(n = 10, data = kr_surf) all_landscapes <- calc_all_lscps(kr_surf, grid_weights = weights) all_landscapes #> An all_lscps object #> - functional characteristics: #>  hydro, curve, mech, fea #> - number of landscapes: #>  286 #> - weights incremented by: #>  0.1 #> - new data: #>  40 rows wprime_by_Group <- calcWprimeBy(all_landscapes, by = ~Ecology)  wprime_by_Group #> - Ecology == \"M\" #>  #> Optimal weights: #>       Weight      SE     SD Min. Max. #> hydro   0.15 0.06455 0.1291  0.0  0.3 #> curve   0.00 0.00000 0.0000  0.0  0.0 #> mech    0.00 0.00000 0.0000  0.0  0.0 #> fea     0.85 0.06455 0.1291  0.7  1.0 #>  #> Average fitness value at optimal weights: #>    Value      SE      SD   Min.   Max. #> Z 0.7686 0.01039 0.02078 0.7444 0.7927 #> ----------------------------------------- #> - Ecology == \"S\" #>  #> Optimal weights: #>        Weight      SE      SD Min. Max. #> hydro 0.85556 0.02422 0.07265  0.8  1.0 #> curve 0.05556 0.02422 0.07265  0.0  0.2 #> mech  0.05556 0.02422 0.07265  0.0  0.2 #> fea   0.03333 0.01667 0.05000  0.0  0.1 #>  #> Average fitness value at optimal weights: #>    Value       SE    SD   Min.   Max. #> Z 0.7496 0.005665 0.017 0.7326 0.7835 #> ----------------------------------------- #> - Ecology == \"T\" #>  #> Optimal weights: #>       Weight      SE     SD Min. Max. #> hydro   0.00 0.00000 0.0000  0.0  0.0 #> curve   0.85 0.06455 0.1291  0.7  1.0 #> mech    0.15 0.06455 0.1291  0.0  0.3 #> fea     0.00 0.00000 0.0000  0.0  0.0 #>  #> Average fitness value at optimal weights: #>    Value       SE      SD  Min.   Max. #> Z 0.7646 0.008862 0.01772 0.744 0.7852 #>  #> - method: chi-squared, quantile = 0.05 summary(wprime_by_Group) #> Optimal weights by Ecology: #>   W_hydro W_curve  W_mech   W_fea       Z #> M 0.15000 0.00000 0.00000 0.85000 0.76856 #> S 0.85556 0.05556 0.05556 0.03333 0.74959 #> T 0.00000 0.85000 0.15000 0.00000 0.76457 plot(wprime_by_Group, ncol = 2) tests <- multi.lands.grp.test(wprime_by_Group) tests #> Pairwise landscape group tests #> - method: chi-squared | quantile: 0.05 #>  #> Results: #>   M S T #> M - 0 0 #> S 0 - 0 #> T 0 0 - #> (lower triangle: p-values | upper triangle: number of matches)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/as_fnc_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a data frame to a fnc_df — as_fnc_df","title":"Convert a data frame to a fnc_df — as_fnc_df","text":"as_fnc_df() converts data frame containing coordinates functional charactertics morphological space  fnc_df object use later funcitons, importantly krige_surf.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/as_fnc_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a data frame to a fnc_df — as_fnc_df","text":"","code":"as_fnc_df(x, func.names = NULL, scale = TRUE)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/as_fnc_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a data frame to a fnc_df — as_fnc_df","text":"x data frame containing coordinates functional characteristics (possibly variables, ignored). first two columns must correspond x y coordinates warps morphological space. func.names names variables x correspond functional characteristics. charcteristics must numeric variables. NULL (default), variables first two taken functional characteristics study. scale whether scale functional characteristics minimum 0 maximum 1. generally left default (TRUE) unless variables already scaled.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/as_fnc_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a data frame to a fnc_df — as_fnc_df","text":"Input data can sampled grid locations morphospace, measured specimen data, species group means, mix.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/as_fnc_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a data frame to a fnc_df — as_fnc_df","text":"fnc_df object, data.frame x y coordinates first two columns functional characteristics columns. \"func.names\" attribute contains names functional characteristics.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/as_fnc_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a data frame to a fnc_df — as_fnc_df","text":"","code":"data(\"warps\")  warps_fnc <- as_fnc_df(warps,                         func.names = c(\"hydro\", \"curve\",                                        \"mech\", \"fea\"))                                         str(warps_fnc) #> Classes ‘fnc_df’ and 'data.frame':\t24 obs. of  6 variables: #>  $ x    : num  -0.189 -0.189 -0.189 -0.189 -0.134 ... #>  $ y    : num  -0.05161 -0.00363 0.04435 0.09233 -0.05161 ... #>  $ hydro: num  0.763 0.627 0.487 0.174 0.858 ... #>  $ curve: num  0.0544 0 0.1045 0.281 0.1202 ... #>  $ mech : num  0.359 0.473 0.446 0 0.149 ... #>  $ fea  : num  0.372 0.458 0.512 0.65 0.777 ... #>  - attr(*, \"func.names\")= chr [1:4] \"hydro\" \"curve\" \"mech\" \"fea\""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute optimally weighted adaptive landscapes — calcGrpWprime","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"calcGrpWprime() computes optimally weighted adaptive landscape searching adaptive landscapes formed sets weights performance surfaces, finding set weights yields greatest overall (average) fitness value (Z) across sample data subset thereof.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"","code":"calcGrpWprime(x, index, method = \"chi-squared\",               quantile = 0.05) # S3 method for class 'grp_Wprime' print(x,        digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"x calcGrpWprime(), all_lscps object; output call calc_all_lscps. print(), grp_Wprime object; output call calcGrpWprime() index optional vector indices indicating subset new_data dataset originally supplied krige_surf calculated. Can specified vector numerical indicies, logical indices, row names. unspecified, optimal weights computed using full sample. Supplied subset, name dataset containing subsetting variable need included subsetting variable new_data. See Examples. method method used compute optimal weights. Allowable options include \"chi-square\" (default), \"quantile\", \"max\". \"chi-square\" \"quantile\" involve averaging across best several sets weights, whereas \"max\" uses singular best set weights. Abbreviations allowed. See Details. quantile method \"chi-square\" \"quantile\", top quantile used determine best sets weights included average compute optimal set weights. number 0 1, low value indicating top sets weights used. Ignored method = \"max\". digits number significant digits print. ... passed print.default.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"calcGrpWprime() calculates overall fitness score set weights based average weighted fitness values indexed subgroup. set weights optimizes score produced weights defining optimal adaptive landscape subgroup. way final set weights computed depends argument method. method = \"max\", single best set weights used. However, often many upper sets weights perform equally nearly equally well best set. instead recommended use \"quantile\" \"chi-squared\" methods. method = \"quantile\", top \\(X\\%\\) weights averaged compute optimal weights, \\(X\\) corresponds value supplied quantile. method = \"chi-square\",  chi-squared value \\(\\chi^2_i\\) computed set weights \\(\\) $$\\chi^2_i = -2 \\log \\frac{Z_{max}}{Z_i}$$ \\(Z_{max}\\) largest \\(Z\\) among weights, p-value computed \\(\\chi^2_i\\) value using \\(\\chi^2\\) distribution 2 d.f.; set weights p-value less quantile included averaged compute optimal set weights.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"grp_Wprime object, contains following components: Zprime list containing optimal weights Z value yield (wn), , method \"chi-square\" \"quantile\", summary statistics best sets weights used compute optimal weights, including standard error (wn.se), standard deviation (wn.sd), range (wn.range). W matrix containing sets weights (.e., supplied grid_weights argument calc_all_lscps()) along Z value yields, ordered descending order yielded Z value. index specified, resulting Z values computed using indexed subset. Wprime wtd_lscp object containing optimal weights (W) landscape grid sample functional characteristcs weighted optimal weights.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"Dickson, B. V., Clack, J. ., Smithson, T. R., & Pierce, S. E. (2021). Functional adaptive landscapes predict terrestrial capacity origin limbs. Nature, 589(7841), 242-245. Jones, K. E., Dickson, B. V., Angielczyk, K. D., & Pierce, S. E. (2021). Adaptive landscapes challenge \"lateral--sagittal\"\" paradigm mammalian vertebral evolution. Current Biology, 31(9), 1883-1892.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcGrpWprime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute optimally weighted adaptive landscapes — calcGrpWprime","text":"","code":"data(\"warps\") data(\"turtles\")  warps_fnc <- as_fnc_df(warps,                         func.names = c(\"hydro\", \"fea\"))  kr_surf <- krige_surf(warps_fnc, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging]  grid_weights <- generate_weights(n = 3, data = kr_surf) #> 4 rows generated  all_lscps <- calc_all_lscps(kr_surf,                             grid_weights = grid_weights)                              wprime_S <- calcGrpWprime(all_lscps,                           index = Ecology == \"S\") wprime_S #> Optimal weights: #>       Weight     SE     SD   Min.   Max. #> hydro 0.8333 0.1667 0.2357 0.6667 1.0000 #> fea   0.1667 0.1667 0.2357 0.0000 0.3333 #>  #> Average fitness value at optimal weights: #>    Value     SE     SD   Min.   Max. #> Z 0.7642 0.0193 0.0273 0.7449 0.7835 #>  #> - method: chi-squared, quantile = 0.05 plot(wprime_S)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate polynomial fits over a surface — calcPoly","title":"Calculate polynomial fits over a surface — calcPoly","text":"calcPoly calls spatial package fit rectangular spatial polynomial surface models least-squares, GLS. methods allow user test whether data spatial trends morphospace. Outputs polynomial trend surface, ANOVA table model fit. multiPoly applies calcPoly fnc_df outputs trait. extensive documentation model fitting see spatial package.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate polynomial fits over a surface — calcPoly","text":"","code":"calcPoly(fnc, npoly = 3, fnc.name = NULL,           gls.covmod = list(covmod = expcov, d = 0.7, alpha = 0, se = 1),           pad = 1.2, resample = 100, range = NULL, verbose = FALSE)                       multiPoly(fnc_df, npoly = 3, ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate polynomial fits over a surface — calcPoly","text":"fnc XYZ dataframe matrix spatially distributed trait. fnc_df functional dataframe as_fnc_df colnames corresponding X,Y trait names. npoly singular numeric. Degree polynomial fit ragning 1-4. multiPoly can also vector length equal numer traits order specify degree polynomial apply trait. gls.covmod Optional list arguments pass surf.gls fitting generalized least-squares desired. Defaults NULL, fitting performed least-squares. See surf.gls expcov documentation full list arguments usage. fnc.name Optional speficiation trait name. Defaults NULL, use column names instead. pad Degree extrapolate input data. Defaults 1.2. resample Resampling density. Corresponds number points calculated along X   Y axes. Defaults 100. resampling desired, set reample = NULL range Optional. Manually set X Y ranges. Input 2x2 matrix rows corresponding X Y    ranges respectively. verbose Optional. Logical. TRUE, print ANOVA tables. ... Arguments pass onto calcPoly using multiPoly","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate polynomial fits over a surface — calcPoly","text":"Fits polynomial trend surfaces using `spatial` package. First, npoly polynomial trend surface fit least squares using surf.ls generalized least-squares surf.gls. GLS fit one three covariance functions, exponential (expcov), gaussian (gaucov) spherical (sphercov) requires additional parameters passed list gls.covmod (see examples). full description arguments usage see surf.gls expcov documentation. surface evaluated using trmat within limits set input data, manually using range.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate polynomial fits over a surface — calcPoly","text":"object class poly_surf, multi_surf following components: fnc.name name trait poly Polynomial trend fit output surf.ls surface Evaluated trend surface output trmat grid Expanded surface long XZY dataframe format peak Coordinates height peak surface","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate polynomial fits over a surface — calcPoly","text":"Dickson, B.V. Pierce, S.E. (2019), Functional performance turtle humerus shape across ecological adaptive landscape. Evolution, 73: 1265-1277. https://doi.org/10.1111/evo.13747","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate polynomial fits over a surface — calcPoly","text":"Blake V. Dickson","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcPoly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate polynomial fits over a surface — calcPoly","text":"","code":"require(spatial) #> Loading required package: spatial  data(\"warps\") warps_fnc <- as_fnc_df(warps)  # Make single trait dataframe  hydro_fnc <- data.frame(warps_fnc[ ,1:2], warps_fnc[ ,\"hydro\"])  polysurf <- calcPoly(hydro_fnc) summary(polysurf) #> - warps_fnc....hydro..  #> npoly:  3  #> peak:   #>           x           y           z  #> -0.07422549 -0.04639033  1.00000000  #>  #> Analysis of Variance Table #>  Model: (function (np, covmod, x, y, z, nx = 1000, ...) {    if (np > 6)         stop(\"'np' exceeds 6\")    if (is.data.frame(x)) {        if (any(is.na(match(c(\"x\", \"y\", \"z\"), names(x)))))             stop(\"'x' does not have columns 'x', 'y' and 'z'\")        if (missing(y))             y <- x$y        if (missing(z))             z <- x$z        x <- x$x    }    rx <- range(x)    ry <- range(y)    .C(VR_frset, as.double(rx[1L]), as.double(rx[2L]), as.double(ry[1L]),         as.double(ry[2L]))    covmod <- covmod    arguments <- list(...)    if (length(arguments)) {        onames <- names(formals(covmod))        pm <- pmatch(names(arguments), onames, nomatch = 0L)        if (any(pm == 0L))             warning(\"some of '...' do not match\")        names(arguments[pm > 0L]) <- onames[pm]        oargs <- formals(covmod)        oargs[pm] <- arguments[pm > 0L]        formals(covmod) <- oargs    }    mm <- 1.5 * sqrt((rx[2L] - rx[1L])^2 + (ry[2L] - ry[1L])^2)    alph <- c(mm/nx, covmod(seq(0, mm, mm/nx)))    .C(VR_alset, as.double(alph), as.integer(length(alph)))    n <- length(x)    npar <- ((np + 1) * (np + 2))/2    f <- .spfmat(x, y, np)    Z <- .C(VR_gls, as.double(x), as.double(y), as.double(z),         as.integer(n), as.integer(np), as.integer(npar), as.double(f),         l = double((n * (n + 1))/2), r = double((npar * (npar +             1))/2), beta = double(npar), wz = double(n), yy = double(n),         W = double(n), ifail = 0L, l1f = double(n * npar))    if (Z$ifail > 0L)         stop(\"rank failure in Choleski decomposition\")    if (nx > 1000L)         alph <- alph[1L]    res <- list(x = x, y = y, z = z, np = np, f = f, alph = alph,         l = Z$l, r = Z$r, beta = Z$beta, wz = Z$wz, yy = Z$yy,         W = Z$W, l1f = Z$l1f, rx = rx, ry = ry, covmod = covmod,         call = match.call())    class(res) <- c(\"trgls\", \"trls\")    res})(np = 3, covmod = function (r, d, alpha = 0, se = 1) {    se^2 * (alpha * (r < d/10000) + (1 - alpha) * exp(-r/d))}, x = c(`1` = -0.189222674092978, `2` = -0.189222674092978, `3` = -0.189222674092978, `4` = -0.189222674092978, `5` = -0.133845239206066, `6` = -0.133845239206066, `7` = -0.133845239206066, `8` = -0.133845239206066, `9` = -0.0784678043191536, `10` = -0.0784678043191536, `11` = -0.0784678043191536, `12` = -0.0784678043191536, `13` = -0.0230903694322413, `14` = -0.0230903694322413, `15` = -0.0230903694322413, `16` = -0.0230903694322413, `17` = 0.032287065454671, `18` = 0.032287065454671, `19` = 0.032287065454671, `20` = 0.032287065454671, `21` = 0.0876645003415833, `22` = 0.0876645003415833, `23` = 0.0876645003415833, `24` = 0.0876645003415833), y = c(`1` = -0.0516138896365427, `2` = -0.00363138024603597, `3` = 0.0443511291444708, `4` = 0.0923336385349775, `5` = -0.0516138896365427, `6` = -0.00363138024603597, `7` = 0.0443511291444708, `8` = 0.0923336385349775, `9` = -0.0516138896365427, `10` = -0.00363138024603597, `11` = 0.0443511291444708, `12` = 0.0923336385349775, `13` = -0.0516138896365427, `14` = -0.00363138024603597, `15` = 0.0443511291444708, `16` = 0.0923336385349775, `17` = -0.0516138896365427, `18` = -0.00363138024603597, `19` = 0.0443511291444708, `20` = 0.0923336385349775, `21` = -0.0516138896365427, `22` = -0.00363138024603597, `23` = 0.0443511291444708, `24` = 0.0923336385349775), z = c(`1` = 0.763499188437312, `2` = 0.627384654347192, `3` = 0.486816967049923, `4` = 0.174142264485349, `5` = 0.857732301856784, `6` = 0.752332848053817, `7` = 0.492353717916519, `8` = 0.276414894820345, `9` = 1, `10` = 0.845494217913583, `11` = 0.642508934612232, `12` = 0.38984057122137, `13` = 0.995858044607531, `14` = 0.821012732300195, `15` = 0.471898305561689, `16` = 0.243166139196157, `17` = 0.879545728740752, `18` = 0.701083365008891, `19` = 0.349124619048563, `20` = 0.0758538303088942, `21` = 0.511206057156924, `22` = 0.661975028175644, `23` = 0.281357500482196, `24` = 0), d = 0.7, alpha = 0, se = 1) #>                Sum Sq Df     Mean Sq  F value     Pr(>F) #> Regression 1.80378676  9 0.200420751 31.79593 8.4249e-08 #> Deviation  0.08824683 14 0.006303345                     #> Total      1.89203360 23                                 #> Multiple R-Squared: 0.9534,\tAdjusted R-squared: 0.9234  #> AIC: (df = 10) -114.5361 #> Fitted: #>     Min      1Q  Median      3Q     Max  #> 0.02863 0.30283 0.55810 0.80552 0.99446  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -0.10958 -0.04286 -0.02556  0.01876  0.11254  #>  plot(polysurf)   # Fit using gls  polysurf <- calcPoly(hydro_fnc, gls.covmod = list(covmod = expcov, d = 0.7, alpha = 0, se = 1)) if (FALSE) { # \\dontrun{ summary(polysurf) } # } plot(polysurf)  # Calculate multiple polynomial surfaces  multi_poly <- multiPoly(warps_fnc) #> polynomials: #> hydro curve  mech   fea  #>     3     3     3     3  if (FALSE) { # \\dontrun{ summary(multi_poly) } # } plot(multi_poly)   # Set manual range  polysurf <- calcPoly(hydro_fnc, range = rbind(range(warps_fnc$x) * 1.2,                                               range(warps_fnc$y) * 1.4))                                                polysurf <- calcPoly(hydro_fnc, range = rbind(c(-0.2, 0.12),                                               c(-0.06, 0.1)) ) if (FALSE) { # \\dontrun{ summary(polysurf) } # }                                               #  # Adjust polynomial degree  multiPoly(warps_fnc, npoly = 2) #> polynomials: #> hydro curve  mech   fea  #>     2     2     2     2  #> A multi_poly object #> - functional characteristics: #> \thydro, curve, mech, fea  # Specify multiple degrees  multi_poly <- multiPoly(warps_fnc, npoly = c(2,3,4,3)) #> polynomials: #> [1] 2 3 4 3  if (FALSE) { # \\dontrun{ summary(polysurf) } # } plot(polysurf)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcWprimeBy.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","title":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","text":"calcWprimeBy() computes optimally weighted adaptive landscape searching adaptive landscapes formed sets weights performance surfaces, finding set weights yields greatest overall (average) fitness value (Z) across subsets sample dataset.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcWprimeBy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","text":"","code":"calcWprimeBy(x, by, method = \"chi-squared\", quantile = 0.05)  # S3 method for class 'by_Wprime' print(x,        digits = max(3L, getOption(\"digits\") - 3L), ...)  # S3 method for class 'by_Wprime' summary(object, ...)  # S3 method for class 'summary.by_Wprime' print(x,        digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcWprimeBy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","text":"x calcWprimeBy(), all_lscps object; output call calc_all_lscps. print.by_Wprime(), by_Wprime object; output call calcWprimeBy(). print.summary.by_Wprime(), by_Wprime object; output call summary.by_Wprime(). one-sided formula containing grouping variable right hand side (e.g., ~g) vector containing subgrouping variable. supplied formula, grouping variable must present global environment new_data component kriged_surfaces object originally supplied calc_all_lscps(). method method used compute optimal weights. Allowable options include \"chi-square\" (default), \"quantile\", \"max\". \"chi-square\" \"quantile\" involve averaging across best several sets weights, whereas \"max\" uses singular best set weights. Abbreviations allowed. See calcGrpWprime details. quantile method \"chi-square\" \"quantile\", top quantile used determine best sets weights included average compute optimal set weights. number 0 1, low value indicating top sets weights used. Ignored method = \"max\". See calcGrpWprime details. digits number significant digits print. ... passed print.default print.table. object by_Wprime object; output call calcWprimeBy().","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcWprimeBy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","text":"calcWprimeBy() splits sample data based variable calls calcGrpWprime subset. main benefit using calcWprimeBy() subgrouping variable part output object therefore can used plotting using plot.by_Wprime.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcWprimeBy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","text":"by_Wprime object contaning following components: subgrouping variable supplied , stored factor \"by_name\" attribute containing name variable. grp_Wprimes list grp_Wprime objects, one level subgrouping variable.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/calcWprimeBy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute optimally weighted adaptive landscapes by subgroup — calcWprimeBy","text":"","code":"data(\"warps\") data(\"turtles\")  warps_fnc <- as_fnc_df(warps,                         func.names = c(\"hydro\", \"fea\"))  kr_surf <- krige_surf(warps_fnc, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging]  grid_weights <- generate_weights(n = 3, data = kr_surf) #> 4 rows generated  all_lscps <- calc_all_lscps(kr_surf,                             grid_weights = grid_weights)                              wprime_Ecology <- calcWprimeBy(all_lscps, by = ~Ecology) wprime_Ecology #> - Ecology == \"M\" #>  #> Optimal weights: #>       Weight     SE     SD   Min.   Max. #> hydro 0.1667 0.1667 0.2357 0.0000 0.3333 #> fea   0.8333 0.1667 0.2357 0.6667 1.0000 #>  #> Average fitness value at optimal weights: #>    Value       SE      SD   Min.   Max. #> Z 0.8019 0.009228 0.01305 0.7927 0.8112 #> ----------------------------------------- #> - Ecology == \"S\" #>  #> Optimal weights: #>       Weight     SE     SD   Min.   Max. #> hydro 0.8333 0.1667 0.2357 0.6667 1.0000 #> fea   0.1667 0.1667 0.2357 0.0000 0.3333 #>  #> Average fitness value at optimal weights: #>    Value     SE     SD   Min.   Max. #> Z 0.7642 0.0193 0.0273 0.7449 0.7835 #> ----------------------------------------- #> - Ecology == \"T\" #>  #> Optimal weights: #>       Weight     SE     SD Min. Max. #> hydro    0.5 0.2152 0.4303    0    1 #> fea      0.5 0.2152 0.4303    0    1 #>  #> Average fitness value at optimal weights: #>    Value      SE      SD   Min.   Max. #> Z 0.2042 0.01049 0.02098 0.1741 0.2217 #>  #> - method: chi-squared, quantile = 0.05 summary(wprime_Ecology) #> Optimal weights by Ecology: #>   W_hydro  W_fea      Z #> M  0.1667 0.8333 0.8019 #> S  0.8333 0.1667 0.7642 #> T  0.5000 0.5000 0.2042 plot(wprime_Ecology)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_Ri.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for calculating Pareto optimality, using the formula of Deakin et al — calc_Ri","title":"Function for calculating Pareto optimality, using the formula of Deakin et al — calc_Ri","text":"Function calculating Pareto optimality, using formula Deakin et al","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_Ri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for calculating Pareto optimality, using the formula of Deakin et al — calc_Ri","text":"","code":"calc_Ri(x, n1, n2)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_Ri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for calculating Pareto optimality, using the formula of Deakin et al — calc_Ri","text":"x grid data objects class 'kriged_surface' 'by_Wprime' n1 Name first trait/group compared n2 Name second trait/group compared","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_Ri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function for calculating Pareto optimality, using the formula of Deakin et al — calc_Ri","text":"Pareto optimality","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_all_lscps.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","title":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","text":"calc_all_lscps() calculates adaptive landscapes set kriged surfaces functional characteristics sets weights characteristics.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_all_lscps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","text":"","code":"calc_all_lscps(kr_data, grid_weights, file = NULL)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_all_lscps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","text":"kr_data kriged_surfaces object; output call krige_surf. grid_weights grid_weights object; output call generate_weights. file path file save resulting output object, may quite large. file path contain .rds .rdata extension, saved using saveRDS save, respectively. See Details load files saving .","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_all_lscps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","text":"calc_all_lscps() computes combined adaptive landscape supplied sets weights. optimal landscape overall certain subsets sample data can found using calcGrpWprime calcWprimeBy. calc_lscp can used extract surface weighted functional characteristics set weights (see Examples). resulting objects large, can good idea save creation, can done automatically using file argument. supplied file extension .rds, saveRDS used save object supplied file path, file can loaded using readRDS. supplied file extension .RData, save used save object supplied file path, file can loaded using load.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_all_lscps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","text":"all_lscps object containing following components: dataframe list grid new_data data frames stored kr_data. wtd_lscps list containing normalized weighted fitness values set weights grid new_data datasets. stored matrices row data point grid new_data column set weights. Values normalized 0-1 raw_lscps list containing raw weighted fitness values set weights grid new_data datasets. stored matrices row data point grid new_data column set weights. grid_weights grid_weights object supplied grid_weights.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_all_lscps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate adaptive landscapes for a matrix of weights — calc_all_lscps","text":"","code":"data(\"warps\") data(\"turtles\")  warps_fnc <- as_fnc_df(warps,                         func.names = c(\"hydro\", \"fea\"))  kr_surf <- krige_surf(warps_fnc, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging]  grid_weights <- generate_weights(n = 20, data = kr_surf) #> 21 rows generated  all_lscps <- calc_all_lscps(kr_surf,                             grid_weights = grid_weights) all_lscps #> An all_lscps object #> - functional characteristics: #> \thydro, fea #> - number of landscapes: #> \t21 #> - weights incremented by: #> \t0.05 #> - new data: #> \t40 rows  # Extract the weighted surface for a single set # of weights (here, the 6th set of weights)  grid_weights[6,] #> hydro   fea  #>  0.75  0.25   wtd_lscp_6 <- calc_lscp(all_lscps, i = 6) wtd_lscp_6 #> A wtd_lscp object #> - weights: #> hydro   fea  #>  0.75  0.25  #> - new data: #> \t40 rows #> \taverage Z = 0.623  # This aligns with the weighted fitness value: mean(all_lscps$wtd_lscps$new_data[,6]) #> [1] 0.6476778"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a single weighted adaptive landscape — calc_lscp","title":"Calculate a single weighted adaptive landscape — calc_lscp","text":"calc_lscp() calculates single weighted landscape set kriged surfaces functional characteristics set weights characteristics. landscape can plotted using plot.wtd_lscp. Additionally computes fitness values sample additional coordinates.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a single weighted adaptive landscape — calc_lscp","text":"","code":"calc_lscp(data, weights, ...)  # S3 method for class 'kriged_surfaces' calc_lscp(data, weights, ...)  # S3 method for class 'all_lscps' calc_lscp(data, weights, i, ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a single weighted adaptive landscape — calc_lscp","text":"data kriged_surfaces all_lscps object; output call krige_surf calc_all_lscps, repsectively. new_data component included data, adaptive landscape produced. weights vector weights, one functional characteristic. weights nonnegative sum 1. data all_lscps object, index set weights grid_weights object supplied calc_all_lscps() use create weighted landscape. ... ignored.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a single weighted adaptive landscape — calc_lscp","text":"calc_lscp() operates kriged surfaces stored data multiplying functional characteristic values point surface grid weights computing sum values arrive \"fitness\" value represented maximum height combined adaptive landscape. new_data component present data (e.g., new_data argument supplied krige_surf() data output call krige_new_data()), weighted fitness values computed coordinates new_data well.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a single weighted adaptive landscape — calc_lscp","text":"wtd_lscp object, contains following components: W named vector supplied weights Wprime list containing weighted grid new_data components data, values functional characteristics location surface weighted supplied weights additiona column, Z, added containing height adaptive landscape point.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a single weighted adaptive landscape — calc_lscp","text":"","code":"data(\"warps\")  warps_fnc <- as_fnc_df(warps, func.names = c(\"hydro\", \"fea\"))  kr_surf <- krige_surf(warps_fnc) #> [using ordinary kriging] #> [using ordinary kriging]  weights <- c(hydro = .5, fea = .5)  w_lscp <- calc_lscp(kr_surf, weights = weights)  plot(w_lscp)   # Adding new_data data(\"turtles\") kr_surf <- krige_new_data(kr_surf, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging]  w_lscp <- calc_lscp(kr_surf, weights = weights) w_lscp #> A wtd_lscp object #> - weights: #> hydro   fea  #>   0.5   0.5  #> - new data: #> \t40 rows #> \taverage Z = 0.575 plot(w_lscp)   ## See further use with calc_all_lscps()  ## at help(\"calc_all_lscps\")"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp_Pareto.html","id":null,"dir":"Reference","previous_headings":"","what":"calc_lscp_Pareto — calc_lscp_Pareto","title":"calc_lscp_Pareto — calc_lscp_Pareto","text":"Given \"by_Wprime\" \"kriged_surfaces\" object, function returns grid x, y values adds unique grid cell identifier","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp_Pareto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calc_lscp_Pareto — calc_lscp_Pareto","text":"","code":"calc_lscp_Pareto(x, n1, n2)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp_Pareto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calc_lscp_Pareto — calc_lscp_Pareto","text":"x \"by_Wprime\" \"kriged_surfaces\" object n1 String, name first trait group compared n2 String, name second trait group compared","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/calc_lscp_Pareto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calc_lscp_Pareto — calc_lscp_Pareto","text":"list contains two elements: \t\t1) tibble containing x,y grid points across morphospace, \ttrait landscape values Z compared point \tassociated Pareto optimality (Ri) values. \t2) character vector containing names groups traits \tPareto optimality compared","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/generate_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a matrix containing weight combinations — generate_weights","title":"Generate a matrix containing weight combinations — generate_weights","text":"generate_weights() generates matrix containing weight combinations set variables set weights sums 1. can supplied calc_all_lscps calculate fitness landscapes corresponding variety possible sets weights weighting functional characteristics. weights generated partitioning weight 1 across however many variables requested possible ways.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/generate_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a matrix containing weight combinations — generate_weights","text":"","code":"generate_weights(step, n, data = NULL, nvar = NULL,                  varnames = NULL, verbose = TRUE)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/generate_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a matrix containing weight combinations — generate_weights","text":"step numeric. step size weight partitions. one step n can specified. n numeric. number weight partitions 0-1. one step n can specified. data optional fnc_df (output as_fnc_df) kriged_surfaces (output krige_surf) object. number variabes names extracted data functional characteristics present . nvar number variables across allocate weights. Ignored data NULL. nvar = NULL varnames supplied, length varnames used nvar. varnames names variables across allocate weights. Ignored data NULL. varnames = NULL nvar supplied, sequence 1 nar used varnames. verbose whether display message noting number sets weights created.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/generate_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a matrix containing weight combinations — generate_weights","text":"generate_weights() works fining possible allocations n objects nvar bins. step supplied, n computed round(1/step), resulting weight partitions may exactly equal step inverse integer. larger n (smaller step) , possible allocations produced (.e., resulting object rows). output generate_weights() can quickly become large increasing number variables, make subsequent analyses slow. recommended start large step size, small n, increment .","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/generate_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a matrix containing weight combinations — generate_weights","text":"grid_weights object, matrix row set weights column variable weights allocated. weights row sum 1.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/generate_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a matrix containing weight combinations — generate_weights","text":"","code":"# Allocating 10 partitions of .1 across 3 variables wmat <- generate_weights(n = 10, nvar = 3) #> 66 rows generated head(wmat) #>        1   2 3 #> [1,] 1.0 0.0 0 #> [2,] 0.9 0.1 0 #> [3,] 0.8 0.2 0 #> [4,] 0.7 0.3 0 #> [5,] 0.6 0.4 0 #> [6,] 0.5 0.5 0  # Allocating 5 partitions of .2 across the 4 functional # characteristics in the warps dataset data(\"warps\")  warps_fnc <- as_fnc_df(warps) wmat <- generate_weights(n = 5, data = warps_fnc) #> 56 rows generated head(wmat) #>      hydro curve mech fea #> [1,]   1.0   0.0    0   0 #> [2,]   0.8   0.2    0   0 #> [3,]   0.6   0.4    0   0 #> [4,]   0.4   0.6    0   0 #> [5,]   0.2   0.8    0   0 #> [6,]   0.0   1.0    0   0  # Using 'step' for the same result: wmat <- generate_weights(step = .2, data = warps_fnc) #> 56 rows generated head(wmat) #>      hydro curve mech fea #> [1,]   1.0   0.0    0   0 #> [2,]   0.8   0.2    0   0 #> [3,]   0.6   0.4    0   0 #> [4,]   0.4   0.6    0   0 #> [5,]   0.2   0.8    0   0 #> [6,]   0.0   1.0    0   0"},{"path":"https://blakedickson.github.io/Morphoscape/reference/get_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"get_grid — get_grid","title":"get_grid — get_grid","text":"Given \"by_Wprime\" \"kriged_surfaces\" object, function returns grid x, y values adds unique grid cell identifier","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/get_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get_grid — get_grid","text":"","code":"get_grid(x)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/get_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get_grid — get_grid","text":"x \"by_Wprime\" \"kriged_surfaces\" object","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/get_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get_grid — get_grid","text":"grid x, y values data, \t\taddition unique grid cell identifier, 'gridID', \t\tneeded correctly reorder data following ranking \t\tfunctions - see .","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate functional characteristics over a grid — krige_surf","title":"Interpolate functional characteristics over a grid — krige_surf","text":"krige_surf() performs automatic manual kriging (.e., interpolation) one functional characteristics spatially distributed morphospace create smoothly kriged surface. Interpolated values can also produced new dataset given coordinates morphological space.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate functional characteristics over a grid — krige_surf","text":"","code":"krige_surf(fnc_df, vgm = NULL, grid = NULL, resample = 100, padding = 1.2, hull = NULL,    alpha = 1, new_data = NULL)                krige_new_data(x, new_data)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate functional characteristics over a grid — krige_surf","text":"fnc_df fnc_df object; output call as_fnc_df, contains coordinates morphological space values functional characteristics warps used create kriged surface. vgm user supplied list variogram models generated gstat::vgm(). supplied, manual kriging performed using gstat::krige. Else, autoKrige called. supplied, list length match number variables grid matrix data frame containing grid points surface interpolated. output call resample_grid. NULL, grid formed calling resample_grid() inputs. resample number points (pixels) x y dimensions create grid. Default 100 kriged surface 100x100=10,000 pixels. Passed resample_grid. Ignored grid NULL. padding number representing much expand grid beyond ranges x- y-coordinates. example, padding = 1.2 (default) expands grid 20% coordinates' ranges direction. Must number greater equal 1. Large numbers imply greater extrapolation, whatever padding added negated hull = TRUE. Passed resample_grid. Ignored grid NULL. hull method restrict kriging alpha hull prevent extrapolation beyond coordinates present fnc_df. Passed resample_grid, uses alphahull concaveman packages. Default alphahull::ahull. hull desired set hull = NULL. NULL, kriging take place rectangular grid spans boundaries coordinates fnc_df. Ignored grid NULL alpha alpha value used create alpha hull. Passed resample_grid eventually alphahull::ahull. Ignored grid NULL. new_data dataset coordinates new sample; values functional characteristics sample interpolated using kriged surface. debug shows warnings called autoKrige. used debugging purposes x \"kriged_surfaces\" object; output call krige_surf().","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interpolate functional characteristics over a grid — krige_surf","text":"krige_surf() implements automap::autoKrige function one spatially distributed traits produce interpolated (extrapolated) surface evenly spaced gridpoints. done automatiically finding best variogram fit non-corrdinate variables fnc_df. details automatic variogram fitting, see automap::autoKrige. Input data fnc_df can unevenly distributed (direct speciments), gridded (determined evenly distributed hypothetical shapes) morphospace. Trait data inputted directly specimen measurements subject error based unevenly points distributed, high resoultion gridded datapoints producing least potential reconstruction error (see Smith et al 2021). default krige_surf create hull strictly prevent extrapolation beyond provided data. produce conservative landscapes. hull set FALSE, function reconstruct rectangle determined XY coordinate ranges supplied fnc_df. Padding applied default (extra 20%) defined padding, expand rectangle beyond supplied points. Reconstructions without hull appropriate trait data determined evenely spaced hypothetical gridpoints. grid provided function strictly interpolate gridded points. krige_new_data() adds new data set supplied kriged_surfaces object interpolates values functional characteristics suppllied sample. used add new dataset kriged_surfaces object produced without new_data supplied replace existing new_data component.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate functional characteristics over a grid — krige_surf","text":"object class kriged_surfaces containing following components: fnc_df original data frame functional characteristics passed fnc_df. autoKrige named list kriged surfaces, one functional characteristic. surface class autoKrige, output call automap::autoKrige. dataframes list two data frames, grid new_data. grid contains coordinates kriged surface grid (x y columns) well interpolated values functional characteristics. new_data contains sample coordinates supplied new_data well interpolated values functional characteristics sample. second component absent new_data = NULL call krige_surf(). krige_new_data(), original kriged_surfaces object, $dataframes$new_data component containing sample coordinates supplied new_data well interpolated values functional characteristics sample.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interpolate functional characteristics over a grid — krige_surf","text":"Smith, S. M., Stayton, C. T., & Angielczyk, K. D. (2021). many trees see forest? Assessing effects morphospace coverage sample size performance surface analysis. Methods Ecology Evolution, 12(8), 1411-1424.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/krige_surf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpolate functional characteristics over a grid — krige_surf","text":"","code":"data(\"warps\")  warps_fnc <- as_fnc_df(warps)  grid <- resample_grid(warps, hull = \"concaveman\", plot = TRUE)   kr_surf <- krige_surf(warps_fnc, grid = grid) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] kr_surf #> A kriged_surfaces object #> - functional characteristics: #> \thydro, curve, mech, fea #> - surface size: #> \t70 by 70 #> \tα-hull applied (α = 1) #> - original data: #> \t24 rows  # Add new data data(\"turtles\") kr_surf <- krige_new_data(kr_surf, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] kr_surf #> A kriged_surfaces object #> - functional characteristics: #> \thydro, curve, mech, fea #> - surface size: #> \t70 by 70 #> \tα-hull applied (α = 1) #> - original data: #> \t24 rows #> - new data: #> \t40 rows plot(kr_surf)   # Doing it all in one step: if (FALSE) { # \\dontrun{ kr_surf <- krige_surf(warps_fnc, new_data = turtles, hull = \"alphahull\") kr_surf } # }  # No hull and padding kr_surf <- krige_surf(warps_fnc, new_data = turtles, hull = NULL, padding = 1.2) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] plot(kr_surf)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Significance tests between sets of weights — lands.grp.test","title":"Significance tests between sets of weights — lands.grp.test","text":"lands.grp.test() performs statistical test whether optimal adaptive landscape two subgroups significantly different . p-value test proportion weight sets shared two subgroups among respective top weight sets. multi.lands.grp.test() performs test pairs subgroups.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Significance tests between sets of weights — lands.grp.test","text":"","code":"lands.grp.test(grpa, grpb, method = \"chi-squared\",                quantile = 0.05)  multi.lands.grp.test(x, method = \"chi-squared\",                      quantile = 0.05)  # S3 method for class 'lands.grp.test' print(x, digits = max(3L, getOption(\"digits\") - 3L), ...)  # S3 method for class 'multi.lands.grp.test' print(x, digits = max(3L, getOption(\"digits\") - 3L),        style = \"matrix\", ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Significance tests between sets of weights — lands.grp.test","text":"grpa, grpb lands.grp.test(), two grp_Wprime objects containing adaptive landscapes compared; output calls calcGrpWprime. x multi.lands.grp.test(), by_Wprime object, output call calcWprimeBy. print(), output call lands.grp.test() multi.lands.grp.test(). method method used determine sets weights \"best\" sets weights comapred two groups. Allowable options include \"chi-squared\" \"quantile\". See calcGrpWprime details. quantile top quantile used determine best sets weights included average compute optimal set weights. number 0 1, low value indicating top sets weights used. See calcGrpWprime details. digits number significant digits print. style display results pairwise tests; allowable options include \"matrix\" \"table\". Abbreviations allowed. ... passed print.default.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Significance tests between sets of weights — lands.grp.test","text":"lands.grp.test() performs pairwise comparisons two adaptive groups comparing number shared landscapes \\(n_{+B}\\) top percentile group total number landscapes top percentile \\(n_{total}\\). probability \\(P(=B)\\) thus calculated : $$ P(=B) = n_{+B}/n_{total} $$ method = \"quantile\" used, top percentile defined quantile. method = \"chi-squared\" used, top percentile calculated chi-squared value \\(\\chi^2_i\\) : $$\\chi^2_i = -2 \\log \\frac{Z_{max}}{Z_i}$$ \\(Z_{max}\\) largest \\(Z\\) among weights, p-value computed \\(\\chi^2_i\\) value using \\(\\chi^2\\) distribution 2 d.f.; set weights p-value less quantile included optimal set weights. multi.lands.grp.test() wrapper lands.grp.test(), applying function pairwise combinations groups calculated calcWprimeBy.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Significance tests between sets of weights — lands.grp.test","text":"lands.grp.test(), lands.grp.test object containing following components: n.match number sets weights match two supplied subgroups p.val p-value test, computed number sets weights match divided number sets weights compared matching matrix containing sets weights match two subgroups method argument supplied method quantile argument supplied quantile multi.lands.grp.test(), multi.lands.grp.test object containing following components: res data frame containing results tests, columns Group Group B indicating groups involved comparison, column Matches containing number matching sets weights comparison, column p value containing p-value test. method argument supplied method quantile argument supplied quantile print.multi.lands.grp.test(), setting style = \"table\" prints res component -; setting style = \"matrix\" creates matrix p-values test diagonal number matches test diagonal.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Significance tests between sets of weights — lands.grp.test","text":"Jones, K. E., Dickson, B. V., Angielczyk, K. D., & Pierce, S. E. (2021). Adaptive landscapes challenge \"lateral--sagittal\"\" paradigm mammalian vertebral evolution. Current Biology, 31(9), 1883-1892.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/lands.grp.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Significance tests between sets of weights — lands.grp.test","text":"","code":"data(\"warps\") data(\"turtles\")  warps_fnc <- as_fnc_df(warps,                         func.names = c(\"hydro\", \"fea\"))  kr_surf <- krige_surf(warps_fnc, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging]  grid_weights <- generate_weights(n = 3, data = kr_surf) #> 4 rows generated  all_lscps <- calc_all_lscps(kr_surf,                             grid_weights = grid_weights)  # Comparing adaptive landscapes of Ecology groups S and M wprime_S <- calcGrpWprime(all_lscps,                           index = Ecology == \"S\") wprime_M <- calcGrpWprime(all_lscps,                           index = Ecology == \"M\") lands.grp.test(wprime_S, wprime_M) #> Landscape group test #> - method: chi-squared | quantile: 0.05 #>  #> Number of matches: 0 #> P-value: 0  # Comparing adaptive landscapes of all Group subgroups wprime_by_Group <- calcWprimeBy(all_lscps, by = ~Group) tests <- multi.lands.grp.test(wprime_by_Group) tests #> Pairwise landscape group tests #> - method: chi-squared | quantile: 0.05 #>  #> Results: #>            box turtle brackish fathead freshwater sea turtle softshell tortoise #> box turtle -          1        3       2          2          1         2        #> brackish   0.25       -        1       1          0          1         0        #> fathead    0.75       1        -       2          1          1         1        #> freshwater 0.5        1        0.6667  -          0          1         0        #> sea turtle 0.5        0        0.3333  0          -          0         2        #> softshell  0.25       1        0.3333  0.5        0          -         0        #> tortoise   0.5        0        0.3333  0          1          0         -        #> (lower triangle: p-values | upper triangle: number of matches) print(tests, style = \"table\") #> Pairwise landscape group tests #> - method: chi-squared | quantile: 0.05 #>  #> Results: #>       Group A    Group B Matches   p value #> 1  box turtle   brackish       1 0.2500000 #> 2  box turtle    fathead       3 0.7500000 #> 3  box turtle freshwater       2 0.5000000 #> 4  box turtle sea turtle       2 0.5000000 #> 5  box turtle  softshell       1 0.2500000 #> 6  box turtle   tortoise       2 0.5000000 #> 7    brackish    fathead       1 1.0000000 #> 8    brackish freshwater       1 1.0000000 #> 9    brackish sea turtle       0 0.0000000 #> 10   brackish  softshell       1 1.0000000 #> 11   brackish   tortoise       0 0.0000000 #> 12    fathead freshwater       2 0.6666667 #> 13    fathead sea turtle       1 0.3333333 #> 14    fathead  softshell       1 0.3333333 #> 15    fathead   tortoise       1 0.3333333 #> 16 freshwater sea turtle       0 0.0000000 #> 17 freshwater  softshell       1 0.5000000 #> 18 freshwater   tortoise       0 0.0000000 #> 19 sea turtle  softshell       0 0.0000000 #> 20 sea turtle   tortoise       2 1.0000000 #> 21  softshell   tortoise       0 0.0000000"},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple Operations on Spatial Data — lscp_operations","title":"Simple Operations on Spatial Data — lscp_operations","text":"Perform simple operations (sum, sub, mult, div) one multiple landscapes (see details use cases)","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple Operations on Spatial Data — lscp_operations","text":"","code":"sum_lscps(lscps, num = NULL, average = TRUE) mult_lscps(lscps, num = NULL) sub_lscps(lscps, binary = FALSE) div_lscps(lscps, binary = FALSE)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple Operations on Spatial Data — lscp_operations","text":"lscps named list containing datasets spatial data apply operations (see details). num Optional. Defaults NULL. vector containing single numeric scalar numeric vector length = lscps scale using sum_lscps mult_lscps(). NULL, functions operate lscps. num provided, functions operate lscps num. binary subracting dividing landscapes, binarize result obtain logical [0,1] result (see details use case) average summation performed, result averaged number landscapes","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simple Operations on Spatial Data — lscp_operations","text":"Simple operations applied one landscapes depending use case. Spatial datasets can supplied XYZ dataframe, landscape output Morphoscape. sum - sum single spatial dataset/landscape single scalar (lscp1 + num1); sum two spatial datasets/landscapes together (lscp1 + lscp2 ... lscpN); sum multiple landscapes multiple scalars ((lscp1, lscp2 ... lscpN) + (num1, num2, ..., numN)) mult - multiply single spatial dataset/landscape single scalar (lscp1 * num1); multiply two spatial datasets/landscapes together (lscp1 * lscp2 ... lscpN); multiply multiple landscapes multiple scalars ((lscp1, lscp2 ... lscpN) * (num1, num2, ..., numN)) sub - substract one spatial dataset/landscape another (lscp1 - lscp2). numeric subtraction desired, use sum_lscps negative num values. div - divide one spatial dataset another (lscp1 / lscp2). sub_lscps() div_lscps can used construct transition landscapes per (Dickson et al 2020) can compare performance two adaptive regimes. binary = T used, result spatial representation parent landscape dominates. However, recommended use trans_lscps adpt_regions calculate transtional landscapes adaptive regions (yet implemented).","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple Operations on Spatial Data — lscp_operations","text":"object class \"combined.surface\" containing XYZ spatial data.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simple Operations on Spatial Data — lscp_operations","text":"Blake V. Dickson","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/lscp_operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple Operations on Spatial Data — lscp_operations","text":"","code":"require(\"Morphoscape\")  data(\"turtles\") data(\"warps\")  fnc_df <- as_fnc_df(warps,                         func.names = c(\"hydro\", \"curve\", \"mech\", \"fea\"))  kr_surf <- krige_surf(fnc_df, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging]  grid_weights <- generate_weights(n = 10, data = kr_surf) #> 286 rows generated  all_lscps <- calc_all_lscps(kr_surf,                             grid_weights = grid_weights)  wprime_S <- calcGrpWprime(all_lscps,                           index = Ecology == \"S\")  wprime_T <- calcGrpWprime(all_lscps,                           index = Ecology == \"T\")                            lscps <- list(wprimeS = wprime_S, wprime_T = wprime_T)                         # summing multiple landscapes together  summed_surfs <- sum_lscps(lscps, average = TRUE)  # summing landscapes by one or more numeric scalars  summed_surfs <- sum_lscps(lscps, num = c(1.5, -1.15)) # multiple numeric, with subtraction  # multiplying mutliple landscapes together mult_surfs <- mult_lscps(lscps) # multiply landscapes together  # multiplying landscapes by one or more numeric scalars mult_surfs <- mult_lscps(lscps, num = 2) # apply numeric multiplier to all landscapes mult_surfs <- mult_lscps(lscps, num = c(1.2, 0.8)) # apply numeric elements to each landscape  # substract or divide two landscapes  sub_surf <- sub_lscps(lscps) div_surf <- div_lscps(lscps)  # with binary result  sub_surf <- sub_lscps(lscps, binary = TRUE) div_surf <- div_lscps(lscps, binary = TRUE)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.kriged_surfaces.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","title":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","text":"plot.kriged_surfaces() produces spatial landscape plots kriged surfaces produced krige_surf.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.kriged_surfaces.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","text":"","code":"# S3 method for class 'kriged_surfaces' plot(x, alpha = 0.5, pt.col = \"black\",      interpolate = TRUE, contour = TRUE, ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.kriged_surfaces.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","text":"x kriged_surfaces object; output call krige_surf. alpha, pt.col new_data component present x, transparency (alpha) color (pt.col) points plotted new samples. interpolate logical; whether smooth plot interpolating across pixels grid. Passed ggplot2::geom_raster. contour logical; whether add contour lines plot illustrate changes fitness landscape. ... ignored.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.kriged_surfaces.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","text":"plot.kriged_surfaces() wrapper ggplot2 raster plotting functions. precise control raster plotting see ggplot2::geom_raster.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.kriged_surfaces.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","text":"ggplot object, can manipulated using ggplot2 functionality.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.kriged_surfaces.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots Kriged surfaces of functional characteristics — plot.kriged_surfaces","text":"","code":"# See examples at help(\"krige_surf\")"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.wtd_lscp.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Adaptive Landscapes — plot.wtd_lscp","title":"Plot Adaptive Landscapes — plot.wtd_lscp","text":"plot plot methods plot adaptive landscape, weighted combination functional surfaces. landscape arise calls calc_lscp, calc_all_lscps, calcGrpWprime, calcWprimeBy.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.wtd_lscp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Adaptive Landscapes — plot.wtd_lscp","text":"","code":"# S3 method for class 'wtd_lscp' plot(x, alpha = 1, pt.col = \"black\",       interpolate = TRUE, contour = TRUE, ...) # S3 method for class 'grp_Wprime' plot(x, alpha = 1, pt.col = \"black\",       interpolate = TRUE, contour = TRUE, ...) # S3 method for class 'by_Wprime' plot(x, level, ncol = 1, alpha = 1,      pt.col = \"black\", interpolate = TRUE, contour = TRUE,       ...)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.wtd_lscp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Adaptive Landscapes — plot.wtd_lscp","text":"x wtd_lscp, grp_Wprime, by_Wprime object, output call calc_lscp, calcGrpWprime, calcWprimeBy, respectively. alpha transparency points data sample. number 0 (fully transparent) 1 (fully opaque). Passed ggplot2::geom_point. pt.col color points data sample. Passed ggplot2::geom_point. interpolate whether interpolate across pixels grid. Passed ggplot2::geom_raster. contour whether display contours grid. level level (subgrouping) variable plotted. missing, plotted. ncol multiple subgroups plotted, many columns plots arranged. ... ignored.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.wtd_lscp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Adaptive Landscapes — plot.wtd_lscp","text":"plotting functions wrappers ggplot2 raster plotting functions. precise control raster plotting see ggplot2::geom_raster.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.wtd_lscp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Adaptive Landscapes — plot.wtd_lscp","text":"ggplot object can adjusted using functions ggplot2.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot.wtd_lscp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Adaptive Landscapes — plot.wtd_lscp","text":"","code":"data(\"warps\") data(\"turtles\")  warps_fnc <- as_fnc_df(warps, func.names = c(\"hydro\", \"fea\"))  kr_surf <- krige_surf(warps_fnc, new_data = turtles) #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging] #> [using ordinary kriging]  weights <- c(hydro = .5, fea = .5)  w_lscp <- calc_lscp(kr_surf, weights = weights)  plot(w_lscp)  plot(w_lscp, countour = FALSE, pt.col = \"white\")   # See help(\"calc_lscp\"), help(\"calcGrpWprime\"), and  # help(\"calcWprimeBy\") for examples when used with # those functions"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggPareto.html","id":null,"dir":"Reference","previous_headings":"","what":"plot_ggPareto — plot_ggPareto","title":"plot_ggPareto — plot_ggPareto","text":"Helper function - plots Pareto optimality Ri across grid. Contours color coded according Ri score. Additionally, Pareto front drawn using geom_smooth subset points whose Ri == maximum Ri","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggPareto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot_ggPareto — plot_ggPareto","text":"","code":"plot_ggPareto(x, n1 = NULL, n2 = NULL)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggPareto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot_ggPareto — plot_ggPareto","text":"x PO_List object, result calc_lscp_Pareto. Alternatively, dataframe tibble containing trait values n1 First variable plot n2 Second variable plot","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggPareto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot_ggPareto — plot_ggPareto","text":"ggplot object","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggsurf.html","id":null,"dir":"Reference","previous_headings":"","what":"plot_ggsurf — plot_ggsurf","title":"plot_ggsurf — plot_ggsurf","text":"Helper function - plots specific performance surface landscape. Data must tabular format. Grid color-coded according trait value Z score.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggsurf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot_ggsurf — plot_ggsurf","text":"","code":"plot_ggsurf(x, n1 = NULL)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggsurf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot_ggsurf — plot_ggsurf","text":"x PO_List object, result calc_lscp_Pareto. Alternatively, dataframe tibble containing trait values n1 Name trait variable group landscape plotted","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggsurf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot_ggsurf — plot_ggsurf","text":"ggplot object","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggtrade.html","id":null,"dir":"Reference","previous_headings":"","what":"plot_ggtrade — plot_ggtrade","title":"plot_ggtrade — plot_ggtrade","text":"Helper function - plots trade-offs different traits landscape Z scores, x-y scatterplot. Points color coded according Pareto optimality Ri score.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggtrade.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot_ggtrade — plot_ggtrade","text":"","code":"plot_ggtrade(x, n1 = NULL, n2 = NULL)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggtrade.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot_ggtrade — plot_ggtrade","text":"x PO_List object, result calc_lscp_Pareto. Alternatively, dataframe tibble containing trait values n1 First variable plot n2 Second variable plot","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_ggtrade.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot_ggtrade — plot_ggtrade","text":"ggplot object","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_lscp_Pareto.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility functions for calculating Pareto optimality — plot_lscp_Pareto","title":"Utility functions for calculating Pareto optimality — plot_lscp_Pareto","text":"Plots Pareto optimality two traits landscapes Z values across morphospace.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_lscp_Pareto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility functions for calculating Pareto optimality — plot_lscp_Pareto","text":"","code":"plot_lscp_Pareto(x, n1 = NULL, n2 = NULL)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_lscp_Pareto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility functions for calculating Pareto optimality — plot_lscp_Pareto","text":"x Output calc_lscps_Pareto n1 First variable plot n2 Second variable plot","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/plot_lscp_Pareto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility functions for calculating Pareto optimality — plot_lscp_Pareto","text":"series ggplot graphs, generated series helper functions. can accessed viewed individually, plotted using 'patchwork' package","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/resample_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a full grid from a set of coordinates — resample_grid","title":"Create a full grid from a set of coordinates — resample_grid","text":"resample_grid() creates rectangular grid around supplied coordinates resampling evenly spaced points minimum maximum values coordinate dimension. grid can optionally reduced convex concave hull around supplied coordinates.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/resample_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a full grid from a set of coordinates — resample_grid","text":"","code":"resample_grid(coords2D, resample = 100, padding = 1.2, hull = NULL, alpha = 1,    plot = FALSE)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/resample_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a full grid from a set of coordinates — resample_grid","text":"coords2D 2-column matrix data frame coordinates x-coordinates first column y-coordinates second column. ranges column used create resampled grid. resample number points (pixels) x y dimensions create grid. Default 100 kriged surface 100x100=10,000 pixels. padding number representing much expand grid beyond ranges x- y-coordinates. example, padding = 1.2 (default) expands grid 20% coordinates' ranges direction. Must number greater equal 1. Large numbers imply greater extrapolation, whatever padding added negated hull specified. hull method restrict grid alpha hull using alphahull] concaveman packages. Default `NULL` hull calculated. alpha hull != NULL, alpha value used create hull. Passed ahull concaveman. plot Logical. hull specified, whether plot resulting hull overlayed original grid. Default TRUE.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/resample_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a full grid from a set of coordinates — resample_grid","text":"data frame two columns, x y, containing resampled coordinate grid. hull specified, points hull absent.","code":""},{"path":[]},{"path":"https://blakedickson.github.io/Morphoscape/reference/resample_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a full grid from a set of coordinates — resample_grid","text":"","code":"data(\"warps\")  warps_fnc <- as_fnc_df(warps)  # hull with plot to see the hull grid <- resample_grid(warps_fnc[c(\"x\", \"y\")],                       hull = \"concaveman\", plot = TRUE)  str(grid) #> 'data.frame':\t4900 obs. of  2 variables: #>  $ x: num  -0.186 -0.182 -0.178 -0.174 -0.17 ... #>  $ y: num  -0.0499 -0.0499 -0.0499 -0.0499 -0.0499 ... #>  - attr(*, \"hull\")= chr \"concaveman\" #>  - attr(*, \"alpha\")= num 1  if (FALSE) { # \\dontrun{ # Alpha hull with plot to see the hull grid <- resample_grid(warps_fnc[c(\"x\", \"y\")],                       hull = \"alphahull\", plot = TRUE) } # }"},{"path":"https://blakedickson.github.io/Morphoscape/reference/sp_vals_from_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"sp_vals_from_grid — sp_vals_from_grid","title":"sp_vals_from_grid — sp_vals_from_grid","text":"Function get heights landscape set species points. given set species coordinates morphospace, function finds closest point landscape grid, assigns values associated grid point species.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/sp_vals_from_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sp_vals_from_grid — sp_vals_from_grid","text":"","code":"sp_vals_from_grid(x, y)"},{"path":"https://blakedickson.github.io/Morphoscape/reference/sp_vals_from_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sp_vals_from_grid — sp_vals_from_grid","text":"x 'by_Wprime' 'PO_List' object - contains functional adaptive landscapes Pareto landscapes want extract heights . y dataframe containing species information morphospace. coordinates columns must labelled 'x' 'y'.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/sp_vals_from_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sp_vals_from_grid — sp_vals_from_grid","text":"dataframe containing species information y, additional columns extracted landscape data","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles.html","id":null,"dir":"Reference","previous_headings":"","what":"Turtle Humeri — turtles","title":"Turtle Humeri — turtles","text":"dataset containing sample 40 turtle humeri used Dickson Pierce (2019). New names added Robert Brocklehurst make consistent prevailing taxonomy.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turtle Humeri — turtles","text":"","code":"data(\"turtles\")"},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Turtle Humeri — turtles","text":"data frame 40 observations following 4 variables. x first axis shape variation determiend -groups principal components analysis y second axis shape variation determiend -groups principal components analysis Group locomotor ecologies turtles Ecology three ecological groups determined Procrustes ANOVA; \"M\" (marine), \"S\" (semiaquatic), \"T\" (terrestrial)","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Turtle Humeri — turtles","text":"Dickson, B.V. Pierce, S.E. (2019), Functional performance turtle humerus shape across ecological adaptive landscape. Evolution, 73: 1265-1277. doi:10.1111/evo.13747","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Trutle Phylogeny — turtles_tree","title":"Trutle Phylogeny — turtles_tree","text":"phylogeny turtles Dickson Pierce (2019) downloaded timetree.org","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trutle Phylogeny — turtles_tree","text":"","code":"data(\"turtles_tree\")"},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles_tree.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Trutle Phylogeny — turtles_tree","text":"phylo object stores turtle phylogeny.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/turtles_tree.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Trutle Phylogeny — turtles_tree","text":"Dickson, B.V. Pierce, S.E. (2019), Functional performance turtle humerus shape across ecological adaptive landscape. Evolution, 73: 1265-1277. doi:10.1111/evo.13747 timetree.org","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/warps.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Shape Warps — warps","title":"Simulated Shape Warps — warps","text":"Trait data simulated shape warps turtle humeri used study morphological evolution turtles Dickson Pierce (2019). morphospace defined geometric morphometric analyises 1028 psuedolandmarks 40 turtle humeri. Hypothetical shape warps produced 4x6 grid accross morphospace. shape warp, four functional traits measured, corresponding locomotory performance trait: stress simulated load (strength), bone curvature (stride length), muscular mechanical advantage (mechanical advantage), frontal area (hydrodynamics).","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/warps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Shape Warps — warps","text":"","code":"data(\"warps\")"},{"path":"https://blakedickson.github.io/Morphoscape/reference/warps.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Shape Warps — warps","text":"data frame 24 observations following 6 variables. x first axis shape variation determiend -groups principal components analysis turtles dataset y second axis shape variation determiend -groups principal components analysis turtles dataset hydro hydrodynamics curve stride length mech mechanical advantage fea strength (assessed using finite element analysis)","code":""},{"path":"https://blakedickson.github.io/Morphoscape/reference/warps.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simulated Shape Warps — warps","text":"Dickson, B.V. Pierce, S.E. (2019), Functional performance turtle humerus shape across ecological adaptive landscape. Evolution, 73: 1265-1277. doi:10.1111/evo.13747","code":""},{"path":"https://blakedickson.github.io/Morphoscape/news/index.html","id":"morphoscape-110","dir":"Changelog","previous_headings":"","what":"Morphoscape 1.1.0","title":"Morphoscape 1.1.0","text":"Updates new functions documentation Pareto landscapes. changes may compatible prior versions.","code":""},{"path":"https://blakedickson.github.io/Morphoscape/news/index.html","id":"morphoscape-100","dir":"Changelog","previous_headings":"","what":"Morphoscape 1.0.0","title":"Morphoscape 1.0.0","text":"CRAN release: 2022-06-17 Full release new functions documentation. changes may compatible prior versions. Added NEWS.md file track changes package.","code":""}]
